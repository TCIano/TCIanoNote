---
layout: post
title: "浏览器"
date: 2022-08-25 11:12:10 +0800
categories: 浏览器
---

## 一、缓存机制

### 1. 概念

+ 浏览器会将第一次请求后的资源存为离线资源，当下次需要该资源时候，浏览器会根据缓存机制决定直接使用缓存还是再次向服务器发送请求。

###  3. 强缓存

+ 不向服务端发送求情，强制使用缓存数据。
+ 浏览器在第一次请求后缓存资源，再次请求时，根据该资源的响应头中的 Expires 和 Cache-Control  都表示资源的有效时间，
+ **Expires**，代表资源失效时间（绝对时间）如果服务端和客户端的时间偏差较大时候，会出现缓存混乱。
+ **Cache-Control**，资源有效时间（相对时间），Date 表示资源发送时间，表示资在Date~Date+有效时间内是有效的。
+ Cache-Control，的优先级高于 Expires 的优先级来判断是否命中强缓存，如果命中且如果资源没有过期，则直接从缓存中拿。
+ 强缓存的状态码一般是 200 。

### 4. 协商缓存

+ **Etag** 字段：表示请求资源在服务器的唯一标识，浏览器可以根据 ETag 值缓存数据，下次请求的时候以 If-None-Match 字段请求
+ **Last-Modified** 字段：用于标记请求资源的最后一次修改时间
+ 由服务器决定缓存资源是否可用。
+ 都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。
+ 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified 或者 Etag。
+ if-Modeified-Since/Last-modified 代表最后文件修改的时间 ， 时间只能精确到秒级。根据文件的最后修改时间判断资源是否有变化。如果资源有变化，就正常返回资源内容，新的 Last-Modified 会在 response header 返回，并在下次请求之前更新本地缓存的 Last-Modified，下次请求时，If-Modified-Since会启用更新后的 Last-Modified。
+ If-None-Match/Etag， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。由 hash 算法算出来的 hash 值。服务器通过比较两者是否一致来判定文件内容是否被改变。
+ 优先级 Cache-Control  > expires > Etag > Last-Modified 

### 5. 操作流程

+ 首先浏览器第一次进入之后，会向服务端发送请求，服务端返回请求结果，并把资源存储到缓存中。
+ 当第二次进入浏览器时，请求资源的前，先判断是否有缓存，如果有缓存，根据 Expires 和 Cache-Control 判断资源是否过期。
  + 如果没有过期那么会直接使用强缓存进行页面加载。
  + 如果过期之后进行协商缓存的。
+ 根据请求头的  If-None-Match 和 if-Modeified-Since 字段向服务器发起请求，判断资源是否更新。
  + 如果资源过期但是没有更新，那么证明当前资源还可以使用，那么可以继续使用缓存然后加载页面。
  + 如果资源更新，那么就返回最新资源和最新的缓存标识，存入缓存中，加载页面。

### ![浏览器缓存](http://liufusong.top/assets/img/hclc.74fe02d1.png)

## 二、同源、跨域

1. 同源：两个页面有相同的协议、域名、端口
2. 同源策略：是浏览器提供的一个安全策略，他规定了：

+ 不可以读取非同源网站的Cookie、Localstorage、IndexedDB

+ 无法获取非同源网页的DOM
+ 无法向非同源地址发送Ajax请求

3. 跨域 ：浏览器的同源策略不允许**非同源**的URL之间进行**交互**

+ 怎么解决跨域：
  + JSONP ：缺点：只支持GET，不支持POST。
    + 通过 script 的 src请求跨域的数据和接口，并用函数调用的形式（callback）接收响应回来的数据
  + CORS：优：GET和POST都支持， 缺：不兼容低版本浏览器。
  + 开启反向代理服务器：一个网页通过访问反向代理服务器，间接的访问另一个网页。

​	浏览器访问本地服务器，因为是同源的，所以会访问成功，再通过本地服务访问远程服务器，服务器和服务器之间没有跨域问题，一次可以请求成功，接着把请求的数据通过本地服务器，传递给浏览器。

![反向代理](https://cdn.jsdelivr.net/gh/TCIano/blog_img/1659925009621-666e4be3-c23b-4ba5-8700-91f4f282e60a.png)

```javascript
//具体配置
vue.config.js

devServer: {
	proxy: {
		'/api': {
			target: '接口url地址'
        }
	}
}
```

