---
layout: post
title:  "Vue 组件通信"
date:   2022-08-11 20:15:51 +0800
categories: Vue
---

## 🔺provide/inject（跨级组件通信）
允许一个祖先组件向其所有不论组件层次有多深的子孙后代注入一个依赖。
祖先组件中通过provide来提供变量，然后在子孙组件中通过inject来注入变量。

1. provide：可以是一个对象或者是一个回调函数（返回一个对象）包含可以注入子孙组件的属性。
1. inject：一个字符串数组或一个对象，对象的 key 是本地的绑定名。

value 是：
在可用的注入内容中搜索用的 key ，或
一个对象，该对象的：

-  from 属性  是在可用的注入内容中搜索用的 key。
-  default 属性  是相当于一个默认值
```vue
<template>
  <div>
    <h1>父组件</h1>
    <!-- <child-1-vue :val="info"></child-1-vue> -->
    <child-1-vue></child-1-vue>
  </div>
</template>

<script>
import child1Vue from "./components/child1.vue";
export default {
  data() {
    return {};
  },
  //作为一个对象
  // provide: {
  //   info: {
  //     uname: "father",
  //     age: 20,
  //   },
  // },

  // 作为一个返回对象的函数
  provide() {
    return {
      obj: {
        uname: "father",
        age: 19,
      },
      info: "789",
    };
  },
  components: {
    child1Vue,
  },
  created() {},

  methods: {},
};
</script>

<style scoped></style>

```
```vue
<template>
  <div>
    <h1>child1，子组件</h1>
    <p>props:{{ val }}</p>
    <child-2-vue></child-2-vue>
  </div>
</template>

<script>
import child2Vue from "./child2.vue";
export default {
  data() {
    return {};
  },
  props: {
    val: {
      type: String,
    },
  },
  components: {
    child2Vue,
  },
  created() {},

  methods: {},
};
</script>

<style scoped></style>

```
```vue
<template>
  <div>
    <h1>child2，孙子组件</h1>
    {{ info }}
    {{ obj.uname }}
  </div>
</template>

<script>
export default {
  data() {
    return {};
  },
  //接收一个字符串数组 ---》'{uname: "father",age: 20,}'
  //   inject: ["info"],

  // 接收一个对象 ---》'{uname: "father",age: 19,}'
  inject: {
    obj: {
      form: "obj",
    },
    info: {
      from: "info",
    },
  },
  created() {},

  methods: {},
};
</script>

<style scoped></style>

```

使用场景：子孙组件和祖先组件之间的通信
## 🔺$attrs/$listeners
场景：多级组件嵌套需要传递数据时，且不需要处理数据的时候。

1. $attrs 里存放的是父组件中绑定的非 Props 属性。
1. $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件
```vue
<template>
  <div>
    <p>祖先组件</p>
    <child-com-1-vue :uname="uname" :age="age" @com1="com1"></child-com-1-vue>
  </div>
</template>

<script>
import childCom1Vue from "./components/childCom1.vue";
export default {
  data() {
    return {
      uname: "ls",
      age: "20",
    };
  },
  components: {
    childCom1Vue,
  },
  created() {},

  methods: {
    com1() {
      console.log("这是祖先组件的方法");
    },
  },
};
</script>

<style scoped></style>

```

```vue
<template>
  <div>
    <p>子组件1</p>
    <child-com-2-vue v-bind="$attrs" v-on="$listeners"></child-com-2-vue>
  </div>
</template>

<script>
import childCom2Vue from "./childCom2.vue";
export default {
  data() {
    return {};
  },
  components: {
    childCom2Vue,
  },
  props: {
    uname: {
      type: String,
    },
  },
  created() {
    console.log(this.$attrs); //----{"age":"20"}
    console.log(this.$listeners);
    this.$listeners.com1(); //----“这是祖先组件的方法”
  },

  methods: {},
};
</script>

<style scoped></style>

```
```vue
<template>
  <div>
    <p>子组件2</p>
    {{ $attrs }} //---{"age":"20"}
  </div>
</template>

<script>
export default {
  data() {
    return {};
  },

  created() {
    console.log(this.$attrs); //---{"age":"20"}
    this.$listeners.com1(); //----"这是祖先组件的方法"
  },

  methods: {},
};
</script>

<style scoped></style>

```

## $parent,$children
$children ：可以获取当前组件的所有子组件，并且以数组的形式返回。
$parent：可以获取当前组件的父组件，并返回当前父组件。

## 🔺eventBus（事件总线）

1. 本质就是一个vue实例
1. 创建 const eventBus = new Vue()
1. 导出 export
1. 在使用的组件中引入 import eventBus from ""
1. eventBus.$emit('事件名'，传递的数据)
1. 另一个组件中注册自定义事件 eventBus.$on('事件名'，（）=>{})
1. 接收事件

设计模式：发布订阅模式：一对多的依赖关系，
    发布方为一，发布消息。
   依赖方为多，订阅消息。

```javascript
class eventBus {
	//定义一个接收事件的对象
	clientList = {},
	$on = function(event,callback){
		//如果没有当前事件，那么就给当前事件名当做一个数组，里面存放事件回调
		if(!this.clientList[event]){
			this.clientList[event] = []
		}
		//如果有当前事件，那么就给当前事件数组添加一个回调
		this.clientList[event].push(callback)
	},
	$emit = function(event,val){
		//把对象里每个属性拿出来放到一个数组中，遍历每个属性名（即对象名）
		Object.keys(this.clientList).forEach(item =>{
			//如果没有该事件，就跳出
			if(!this.clientList[event]){
				return false
			}
			
			//给每个属性里面的每个方法传递参数。
			this.clientList[event].forEach(callback =>{
				callback(val)
			})
			
		})
	}
}

//new 一个事件总线实例
const event  = new eventBus()
//订阅事件
event.$on('send',(val)=>{
	console.log(val)
})
event.$on('send',(val)=>{
	console.log(val)
})

//发布事件,并且给回调传参
event.$emit('send',1)
```
