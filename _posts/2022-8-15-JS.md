---
layout: post
title: "JS笔记"
date: 2022-08-15 20:12:10 +0800
categories: JS
---



# JS

## 一、Promise

### 1.概述

- 是一个构造函数（对象），ES6新增的。


- 提供了一种解决异步的方法，而且解决了回调地狱的问题。
- 三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已拒绝）
- 实例方法：Promise.then / catch /finally
- 静态方法： all / allsettled / race / any

1. 当把一个任务交给 promise 的时候，它的状态就是Pending，任务完成之后状态变为Resolved，没有完成失败就变成了Rejected。
2. 一旦状态发生改变，那么就不能更改状态了。

### 2. then（解决回调地狱）

1. then 的默认返回值是Promise
2. 成功的结果通过 resolve 传递给 then ，下一次的异步可以在下一个 then 中进行可以一直链式调用。
3. then 的回调函数中如果写了 return，该值当做 Promise 的成功结果传递给下一个 then 
4. 如果在 then 中单独返回一个 promise ，那么下一次 then 的成功结果来自于上一个then 中成功回调里面返回的 promise 的 resolve 的结果。
5. then 的中断：可以通过回调中的 reject / throw new Error 进行中断。

### 3. await async

1. await 用来修饰 promise。
2. async 用来修饰 await 就近的函数。
3. async 修饰的函数返回值为 promise。
4. 被 async 修饰的函数一定可以被 await 修饰。

### 4. 静态方法

1. Promise.all（）
   + 可以获取多个 promise 处理异步的结果，返回值是 promise
   + 可以调用 .then（），当all 数组中所有promise 都resolve（）之后才执行 then ，只要有一个reject（）那么就中断。
   + all 的then 返回的结果就是对应的 promise 返回的数据
2. Promise.allsettled（）
   - 也可以获取多个 promise 异步处理的结果，不管 resolve 还是 reject 都会执行 then ，结果返回一个数组，每个对象通过 status 记录对应 promise 的状态（ fulfilled / rejected ） 
3. Promise.race（）
   - 和 all 一样，只返回第一个结果（成功或者失败）。	
4. Promise.any（）
   - 返回多个 promise 处理结果中第一个成功的结果。

### 5. Generator 函数

**概念**：可以将函数的控制权交出（将函数的执行暂停），也可以利用其更方便的控制异步

格式：用 * 来标记 generator 函数，用 yield 来进行函数暂停（交出控制权）。

```javascript
function *fn（）{ 
  //yield 交出控制权
	yield console.log(1)
     yield console.log(2)
     return 3
}
```

**逐步调用**：

```javascript
const gen = fn()
gen.next()
```

**向外传递数据** ：调用next（）会返回一个对象，对象里有两个属性，一个是value（每次的返回值），一个是done（函数是否执行结束）

```javascript
function *fn（）{ 
	yield 1
     yield 2
     return 3
}
const gen = fn()
console.log(gen.next（）)//{value:1,done:false}
console.log(gen.next（）)//{value:2,done:false}
console.log(gen.next（）)//{value:3,done:true}
```

**处理异步**：配合 promise 处理

```javascript
function *fn() {
   yield new Promise(resolve => {
    setTimeout(() => {
      console.log(1)
      resolve()
    }, 2000)
  })

  yield new Promise(resolve => {
    setTimeout(() => {
      console.log(2)
      resolve()
    }, 1000)
  })

  yield new Promise(resolve => {
    setTimeout(() => {
      console.log(3)
      resolve()
    }, 3000)
  })
}

const gen = fn()
//调用（回调地狱）
gen.next().value.then(() => {
  gen.next().value.then(() => {
    gen.next()
  })
})

//利用co 递归
function co(gen) {
  //res 的value属性里是一个  promise 对象
  const res = gen.next()
  //如果函数执行完毕就结束递归
  if (res.done) return
  //拿到 promise 的 成功回调的返回数据
  res.value.then(() => {
    co(gen)
  })
}
```





